from django.db import models
from django.contrib.auth.models import User
from django.core.validators import MinValueValidator, MaxValueValidator
from django.utils import timezone
from django.db.models import Sum


class Category(models.Model):
    """Workshop categorie (bijv. Houtbewerking, Metaalbewerking, Kunst)"""
    name = models.CharField('Naam', max_length=100, unique=True)
    slug = models.SlugField('Slug', max_length=100, unique=True)
    description = models.TextField('Beschrijving', blank=True)
    icon = models.CharField(
        'Bootstrap Icon', 
        max_length=50, 
        default='bi-lightbulb',
        help_text='Bootstrap icon class (bijv. bi-cpu, bi-gear, bi-rocket). Zie https://icons.getbootstrap.com/'
    )
    created_at = models.DateTimeField('Aangemaakt op', auto_now_add=True)

    class Meta:
        verbose_name = 'Categorie'
        verbose_name_plural = 'Categorieën'
        ordering = ['name']

    def __str__(self):
        return self.name


class Workshop(models.Model):
    """Workshop model voor alle workshop informatie"""
    
    STATUS_CHOICES = [
        ('upcoming', 'Binnenkort'),
        ('active', 'Actief'),
        ('full', 'Volzet'),
        ('cancelled', 'Geannuleerd'),
        ('completed', 'Afgelopen'),
    ]

    # Basis informatie
    title = models.CharField('Titel', max_length=200)
    slug = models.SlugField('Slug', max_length=200, unique=True)
    description = models.TextField('Beschrijving')
    short_description = models.CharField('Korte beschrijving', max_length=300, blank=True)
    
    # Categorie
    category = models.ForeignKey(
        Category, 
        on_delete=models.SET_NULL, 
        null=True, 
        blank=True,
        verbose_name='Categorie',
        related_name='workshops'
    )
    
    # Datum en tijd
    start_datetime = models.DateTimeField('Start datum & tijd')
    end_datetime = models.DateTimeField('Eind datum & tijd')
    duration_hours = models.DecimalField(
        'Duur (uren)', 
        max_digits=4, 
        decimal_places=1,
        validators=[MinValueValidator(0.5)]
    )
    
    # Locatie
    location = models.CharField('Locatie', max_length=200)
    address = models.CharField('Adres', max_length=300, blank=True)
    city = models.CharField('Stad', max_length=100, default='Gent')
    
    # Capaciteit
    max_participants = models.PositiveIntegerField(
        'Maximum aantal deelnemers',
        validators=[MinValueValidator(1), MaxValueValidator(100)]
    )
    min_participants = models.PositiveIntegerField(
        'Minimum aantal deelnemers',
        default=1,
        validators=[MinValueValidator(1)]
    )
    
    # Prijzen
    price = models.DecimalField(
        'Prijs per persoon (€)', 
        max_digits=8, 
        decimal_places=2,
        validators=[MinValueValidator(0)]
    )
    
    # Extra informatie
    materials_included = models.BooleanField('Materialen inbegrepen', default=True)
    requirements = models.TextField('Vereisten', blank=True, help_text='Bijv. ervaring, leeftijd, etc.')
    what_to_bring = models.TextField('Wat meenemen', blank=True)
    
    # Media
    image = models.ImageField('Afbeelding', upload_to='workshops/', blank=True, null=True)
    
    # Status en zichtbaarheid
    status = models.CharField('Status', max_length=20, choices=STATUS_CHOICES, default='upcoming')
    is_active = models.BooleanField('Actief', default=True)
    featured = models.BooleanField('Uitgelicht', default=False)
    
    # Instructor
    instructor_name = models.CharField('Instructeur naam', max_length=200)
    instructor_bio = models.TextField('Instructeur bio', blank=True)
    
    # Metadata
    created_at = models.DateTimeField('Aangemaakt op', auto_now_add=True)
    updated_at = models.DateTimeField('Geüpdatet op', auto_now=True)

    class Meta:
        verbose_name = 'Workshop'
        verbose_name_plural = 'Workshops'
        ordering = ['-start_datetime']
        indexes = [
            models.Index(fields=['start_datetime']),
            models.Index(fields=['status']),
            models.Index(fields=['is_active']),
        ]

    def __str__(self):
        """String representatie met fallback voor title en start_datetime"""
        title = self.title or "Workshop"
        if getattr(self, "start_datetime", None):
            return f"{title} - {self.start_datetime.strftime('%d/%m/%Y')}"
        return title

    @property
    def available_spots(self):
        """
        Aantal beschikbare plaatsen.
        Werkt ook wanneer de instance nog niet is opgeslagen (pk is None).
        """
        total = self.max_participants or 0
        
        # Als de workshop nog geen PK heeft, kunnen we geen relaties opvragen
        if not self.pk:
            return total
        
        confirmed = (
            self.bookings
            .filter(status="confirmed")
            .aggregate(total=Sum("number_of_participants"))
            .get("total") or 0
        )
        
        remaining = total - confirmed
        return max(remaining, 0)

    @property
    def is_full(self):
        """Check of workshop vol is"""
        return self.available_spots <= 0

    @property
    def is_upcoming(self):
        """Check of workshop in de toekomst is"""
        return self.start_datetime > timezone.now()

    def save(self, *args, **kwargs):
        # Auto-update status als vol
        if self.is_full and self.status != 'full':
            self.status = 'full'
        super().save(*args, **kwargs)


class Booking(models.Model):
    """Boeking/Reservering voor een workshop"""
    
    STATUS_CHOICES = [
        ('pending', 'In afwachting'),
        ('confirmed', 'Bevestigd'),
        ('cancelled', 'Geannuleerd'),
        ('completed', 'Voltooid'),
    ]

    PAYMENT_STATUS_CHOICES = [
        ('unpaid', 'Onbetaald'),
        ('paid', 'Betaald'),
        ('refunded', 'Terugbetaald'),
    ]

    # Workshop en deelnemer
    workshop = models.ForeignKey(
        Workshop, 
        on_delete=models.CASCADE, 
        related_name='bookings',
        verbose_name='Workshop'
    )
    user = models.ForeignKey(
        User, 
        on_delete=models.CASCADE, 
        related_name='bookings',
        verbose_name='Gebruiker',
        null=True,
        blank=True
    )
    
    # Aantal deelnemers
    number_of_participants = models.PositiveIntegerField(
        'Aantal deelnemers',
        default=1,
        validators=[MinValueValidator(1), MaxValueValidator(10)]
    )
    
    # Contact informatie (voor niet-ingelogde gebruikers)
    first_name = models.CharField('Voornaam', max_length=100)
    last_name = models.CharField('Achternaam', max_length=100)
    email = models.EmailField('Email')
    phone = models.CharField('Telefoonnummer', max_length=20)
    
    # Deelnemers details (optioneel)
    participants_details = models.JSONField(
        'Deelnemers details',
        blank=True,
        null=True,
        help_text='Extra informatie over deelnemers'
    )
    
    # Betaling
    total_price = models.DecimalField(
        'Totaalprijs (€)', 
        max_digits=10, 
        decimal_places=2
    )
    payment_status = models.CharField(
        'Betalingsstatus',
        max_length=20,
        choices=PAYMENT_STATUS_CHOICES,
        default='unpaid'
    )
    
    # Status
    status = models.CharField(
        'Boekingsstatus',
        max_length=20,
        choices=STATUS_CHOICES,
        default='pending'
    )
    
    # Extra informatie
    notes = models.TextField('Opmerkingen', blank=True)
    dietary_requirements = models.TextField('Dieetwensen', blank=True)
    
    # Metadata
    booking_reference = models.CharField(
        'Boekingsreferentie',
        max_length=20,
        unique=True,
        editable=False
    )
    created_at = models.DateTimeField('Geboekt op', auto_now_add=True)
    updated_at = models.DateTimeField('Geüpdatet op', auto_now=True)
    confirmed_at = models.DateTimeField('Bevestigd op', null=True, blank=True)
    cancelled_at = models.DateTimeField('Geannuleerd op', null=True, blank=True)

    class Meta:
        verbose_name = 'Boeking'
        verbose_name_plural = 'Boekingen'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['booking_reference']),
            models.Index(fields=['status']),
            models.Index(fields=['created_at']),
        ]

    def __str__(self):
        return f"Boeking {self.booking_reference} - {self.workshop.title}"

    def save(self, *args, **kwargs):
        # Generate booking reference als nieuw
        if not self.booking_reference:
            import uuid
            self.booking_reference = f"WS{uuid.uuid4().hex[:8].upper()}"
        
        # Auto-calculate total price
        if not self.total_price:
            self.total_price = self.workshop.price * self.number_of_participants
        
        # Set confirmed_at timestamp
        if self.status == 'confirmed' and not self.confirmed_at:
            self.confirmed_at = timezone.now()
        
        # Set cancelled_at timestamp
        if self.status == 'cancelled' and not self.cancelled_at:
            self.cancelled_at = timezone.now()
        
        super().save(*args, **kwargs)


class Review(models.Model):
    """Review voor een workshop"""
    
    workshop = models.ForeignKey(
        Workshop,
        on_delete=models.CASCADE,
        related_name='reviews',
        verbose_name='Workshop'
    )
    booking = models.ForeignKey(
        Booking,
        on_delete=models.CASCADE,
        related_name='review',
        verbose_name='Boeking',
        null=True,
        blank=True
    )
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='reviews',
        verbose_name='Gebruiker'
    )
    
    # Review content
    rating = models.PositiveIntegerField(
        'Beoordeling',
        validators=[MinValueValidator(1), MaxValueValidator(5)]
    )
    title = models.CharField('Titel', max_length=200)
    comment = models.TextField('Commentaar')
    
    # Metadata
    created_at = models.DateTimeField('Aangemaakt op', auto_now_add=True)
    updated_at = models.DateTimeField('Geüpdatet op', auto_now=True)
    is_approved = models.BooleanField('Goedgekeurd', default=True)

    class Meta:
        verbose_name = 'Review'
        verbose_name_plural = 'Reviews'
        ordering = ['-created_at']
        unique_together = ['workshop', 'user']

    def __str__(self):
        return f"{self.rating}★ - {self.workshop.title} door {self.user.get_full_name()}"


class NewsletterSubscriber(models.Model):
    """Nieuwsbrief inschrijvingen"""
    
    email = models.EmailField('Email adres', unique=True)
    first_name = models.CharField('Voornaam', max_length=100, blank=True)
    last_name = models.CharField('Achternaam', max_length=100, blank=True)
    
    # Status
    is_active = models.BooleanField('Actief', default=True)
    confirmed = models.BooleanField('Bevestigd', default=False)
    
    # Metadata
    subscribed_at = models.DateTimeField('Ingeschreven op', auto_now_add=True)
    unsubscribed_at = models.DateTimeField('Uitgeschreven op', null=True, blank=True)
    
    # Preferences (optioneel voor later)
    interests = models.JSONField(
        'Interesses',
        blank=True,
        null=True,
        help_text='Categorieën waar de subscriber in geïnteresseerd is'
    )

    class Meta:
        verbose_name = 'Nieuwsbrief Inschrijving'
        verbose_name_plural = 'Nieuwsbrief Inschrijvingen'
        ordering = ['-subscribed_at']
        indexes = [
            models.Index(fields=['email']),
            models.Index(fields=['is_active']),
        ]

    def __str__(self):
        name = f"{self.first_name} {self.last_name}" if self.first_name else self.email
        return f"{name} - {'Actief' if self.is_active else 'Inactief'}"
